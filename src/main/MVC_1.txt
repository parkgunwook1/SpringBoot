웹 서버(Web Server)
- HTTP 기반으로 동작
- 정적 리소스 제공, 기타 부가기능
- 정적(파일) = HTML, CSS, JS, 이미지 , 영상
대표적으로 NGINX, APACHE가 있다.

웹 애플리케이션 서버(WAS - Web Application Server)
- HTTP 기반으로 동작
- 웹 서버 기능 포함 + (정적 리소스 제공 가능)
- 프로그램 코드를 실행해서 애플리케이션 로직 수행
    - 동적 HTML, HTTP API(JSON)
    - 서블릿, JSP, 스프링 MVC
대표적으로 톰캣 jetty, Undertow가 있다.

웹 서버, 웹 애플리케이션 서버 차이
- 웹 서버는 정적 리소스만 처리할 수 있고, WAS는 애플리케이션 로직을 처리해서 동적 처러기 가능하다.
- WAS는 애플리케이션 코드를 실행하는데 더 특화되었다.

웹 시스템 구성에서 최소로는 WAS, DB가 있다.
- WAS, DB만으로 시스템 구성 가능
- WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능하다.
하지만! 최소한으로 두 개만 사용한다면 ~
- WAS가 너무 많은 역할을 담당해서 서버 과부하 우려가있다.
- 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있다.
- WAS 장애시 오류 화면도 노출 불가능하다.

그래서 일반적으로는 WEB,WAS,DB를 사용한다
- 정적 리소스는 웹 서버가 처리
- 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임
- WAS는 중요한 애플리케이션 로직 처리 전담

위처럼 사용하면 효율적인 리소스 관리가 된다.
- 정적 리소스가 많이 사용되면 Web 서버 증설만 하면 되고,
- 애플리케이션 리소스가 많이 사용되면 WAS만 증설하면 된다.

정적 리소스만 제공하는 웹 서버는 잘 죽지 않는다.
반면, 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽는다. 그래서 WAS,DB 장애시 WEB 서버가 오류 화면 제공해주면 된다.

서블릿
- urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행
- HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
- HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
- 개발자는 서블릿 때문에 HTTP 스펙을 매우 편리하게 사용할 수 있다.

서블릿 컨테이너
- 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리를 한다.
- 서블릿 객체는 싱글톤으로 관리한다.
- JSP도 서블릿으로 변환 되어서 사용한다.
- 동시 요청을 위한 멀티 쓰레드 처리를 지원한다.

요청을 하면 스레드를 사용해 서블릿으로 응답을한다.
쓰레드
- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 스레드가 실행
- 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
- 스레드는 한번에 하나의 코드 라인만 수행
- 동시 처리가 필요하다면 스레드를 추가로 생성해라

요청 마다 쓰레드 생성 장단점
- 장점
    - 동시 요청을 처리할 수 있다.
    - 리소스(cpu, 메모리)가 허용할 때 까지 처리 가능하다.
    - 하나의 스레드가 지연 되어도, 나머지 스레드는 정상 작동된다.
- 단점
    - 스레드는 생성 비용이 매우 비싸다
        - 고객의 요청이 올 때마다 스레드를 생성하면, 응답 속도가 늦어진다.
    - 스레드는 컨텍스트 스위칭 비용이 발생한다.
    - 스레드 생성에 제한이 없다.
        - 고객 요청이 너무 많이 오면, cpu, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

쓰레드 풀 - 요청마다 쓰레드 생성의 단점 보완
- 특징
    - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
    - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정(변경 가능)
- 사용
    - 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.
    - 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
    - 최대 쓰레드가 모두 사용중이여서 쓰레드 풀에 스레드가 없으면?
        - 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.
- 장점
    - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(cpu)이 절약되고, 응답 시간이 빠르다.
    - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

쓰레드 풀 - 실무 팁
- WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread) 수이다.
- 이 값을 너무 낮게 설정하면?
    - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
- 이 값을 너무 높게 설정하면?
    - 동시 요청이 많으면, cpu, 메모리 리소스 임계점 초과로 서버 다운
- 장애 발생시?
    - 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
    - 클라우드가 아니면 열심히 튜닝

쓰레드 풀 - 쓰레드 풀의 적정 숫자
- 적정 숫자는 애플리케이션 로직의 복잡도, cpu, 메모리 , IO 리소스 상황에 따라 모두 다름
- 아무리 잘하는 사람이라도 바로 못낸다. 그래서 성능 테스트를 꼭 해봐야한다.
    - 최대한 실제 서비스와 유사하게 성능 테스트 시도
    - 툴 : 아파치 ab, 제이미터, nGrinder

WAS의 멀티 쓰레드 지원
- 멀티쓰레드에 대한 부분은 WAS가 처리
- 개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도됨
- 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발
- 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용

HTTP API 다양한 시스템 연동
- 주로 JSON 형태로 데이터 통신
- UI 클라이언트 접점
    - 앱 클라이언트
    - 웹 브라우저에서 자바스크립트를 통한 HTTP API 호출
    - React, Vue.js 같은 웹 클라이언트
- 서버 to 서버
    - 주문 서버 -> 결제 서버
    - 기업간 데이터 통신

백엔드 개발자는 정적 리소스(고정된 html,css,js), 동적 html 페이지, HTTP API를 어떻게 제공할 것인지 고민을 해야한다.

SSR - 서버 사이드 렌더링
    - HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
    - 주로 정적인 화면에 사용
    - 관련기술 : JSP, 타임리프 -> 백엔드 개발자
CSR - 클라이언트 사이드 렌더링
    - HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용
    - 주로 동적인 화면에 사용, 웹 환경을 마치 앱 처럼 필요한 부분부분 변경할 수 있음
    - 예) 구글 지도, Gmail, 구글 캘린더
    - 관련기술 : React, Vue.js -> 웹 프론트엔드 개발자
참고
    - React, Vue.js를 CSR + SSR 동시에 지원하는 웹 프레임워크도 있음
    - SSR을 사용하더라도, 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능

백엔드 - 서버 사이드 렌더링 기술
    - JSP, 타임리프가 있지만, 요즘은 JSP는 거의 없어지고, 스프링에서 타임리프를 밀기 때문에 타임리프 공부하는 것이 좋다.
    - 화면이 정적이고, 복잡하지 않을 때 사용
    - 백엔드 개발자는 서버 사이드 렌더링 기술 학습이 필수다.

자바 웹 기술 역사 - 과거 기술
- 서블릿 - 1977
    - HTML 생성이 어려움
- JSP - 1999
    - HTML 생성은 편리하지만, 비즈니스 로직까지 너무 많은 역할을 담당
- 서블릿, .JSP 조합 MVC 패턴 사용
    - 모델, 뷰, 컨트롤러로 역할을 나누어 개발
- MVC 프레임워크 춘추 전국 시대 2000년 초 ~ 2010년 초
    - MVC 패턴 자동화, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능 지원
(현재 사용 기술)
- 애노테이션 기반의 스프링 MVC 등장
    - @Controller
    - MVC 프레임워크의 춘추 전국 시대 마무리
- 스프링 부트의 등장
    - 스프링 부트는 서버를 내장
    - 과거에는 서버에 WAS를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS에 배포
    - 스프링 부트는 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화

(최신기술)
- Web Servlet - Spring MVC => 서블릿 기반 위에서 사용
    - 멀티 쓰레드 사용
    - request, response 객체 사용 등.
- Web Reactive - Spring WebFlux
    - 특징
        - 비동기 넌 블러킹 처리
        - 최소 쓰레드로 최대 성능 - 쓰레드 컨텍스트 스위칭 비용 효율화
        - 함수형 스타일로 개발 - 동시처리 코드 효율화
        - 서블릿 기술 사용 X
    - 그런데
        - 웹 플럭스는 기술적 난이도 매우 높음
        - 아직은 RDB 지원 부족
        - 일반 MVC의 쓰레드 모델도 충분히 빠르다.
        - 실무에서 아직 많이 사용하지 않음

자바 뷰 템플릿 역사 HTML을 편리하게 생성하는 뷰 기능
- JSP
    - 속도 느림, 기능 부족
- 프리마커, 벨로시티
    - 속도 문제 해결, 다양한 기능
- 타임리프
    - 내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용 가능
    - 스프링 MVC와 강력한 기능 통합
    - 최선의 선택, 단 성능은 프리마커, 밸로시티가 더 빠름

MVC 프레임워크 만들기
"프론트 컨트롤러 도입 전"
클라이언트가 호출할 때마다 컨트롤러를 계속 만들어줘야 한다. 그래서 각 클라이언트들은 Controller A,B,C에 대해 각각 호출해야한다.
즉, 공통 코드들은 별도로 처리되어 있지 않고 각 Controller에 포함되어 있다.

"프론트 컨트롤러 도입 후"
각 클라이언트들은 Front Controller에 요청을 보내고 Front Controller은 각 요청에 맞는 컨트롤러를 찾아서 호출시킨다.
공통 코드에 대해서는 Front Controller에서 처리하고, 서로 다른 코드들만 각 Controller에서 처리할 수 있도록 할 수 있다.

"FrontController 패턴 특징"
- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받는다.
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
- 입구를 하나로! 즉, 공통 처리 가능하다.
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 된다.

"스프링 웹 mvc와 프론트 컨트롤러"
스프링 웹 MVC의 핵심도 바로 "FrontController" 스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현되어 있다.

"urlPatterns"
- urlPatterns = "/front-controller/v1/*" : /front/controller/v1를 포함한 하위 모든 요청은 이 서블릿에서 받아들인다.
예) /front-controller/v1 , /front-controller/v1/a , /front-controller/v1/a/b

"controllerMap"
- key : 매핑된 URL
- value : 호출된 컨트롤러


Model 추가 - V3
"서블릿 종속성 제거"
컨트롤러 입장에서 HttpServletRequest, HttpServletResponse 이 꼭 필요할까?
요청 파라미터 정보는 자바의 Map으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
그리고 request 객체를 Model로 사용하는 대신에 별도의 Model 객체를 만들어서 반환하면 된다,
우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해보겠다. 이렇게 하면 구현 코드가 매우 단순해지고, 테스트 코드 작성이 쉽다.

"뷰 이름 중복 제거"
컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화하자.
이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.


"단순히고 실용적인 컨트롤러 v-4"
컨트롤러 인터페이스를 구현하는 개발자 입장에서 보면, 항상 ModelView 객체를 생성하고 반환해야 하는 부분이 조금 번거롭다.
좋은 프레임워크는 아키텍처도 중요하지만, 그와 더불어 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다. 소위 실용성이 있어야한다.







