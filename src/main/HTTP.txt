HTTP
이제는 모든것을 HTTP에 담아서 통신한다.
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용한다.
이제는 HTTP 시대이다.

HTTP/1.1 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전
    - RFC72300 ~ 7235

기반 프로토콜
- TCP : HTTP/1.1, HTTP/2는 TCP 기반이다.
- UDP : HTTP/3는 UDP 기반이다.
- 현재 HTTP/1.1 주로 사용
    - HTTP/2, HTTP/3도 점점 증가

HTTP 특징
- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

HTTP는 클라이언트 서버 구조로 되어있다.
- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답
클라이언트가 요청을 보내면 서버는 올때까지 기다리다가 응답을 보낸다.

Stateful, Stateless 차이
정리
- 상태 유지 : 중간에 다른 점원으로 바뀌면 안된다.
            (중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)
- 무상태 : 중간에 다른 점원으로 바뀌어도 된다.
         - 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
         - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
       - 무상태는 응답 서버를 쉽게 바꿀 수 있다. -> 무하한 서버 증설 가능

상태 유지 - Stateful
- 항상 같은 서버 유지되어야 한다.

무상태 - Stateless
- 상태를 보관하지 않고 응답한다.
- 서버가 장애나도 다른 서버로 전달 가능하다.

무상태 - Stateless
스케일 아웃 - 수평 확장 관리

Stateless 실무한계
- 모든것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
- 상태 유지는 최소한만 사용해야 한다.

Stateless 단점
- 데이터를 너무 많이 보내야 한다.

정리
웹 애플리케이션 설계는 최대한 무상태로 설계한다.
어쩔수 없는 경우에 한에서만 상태유지를 한다.

비연결성
- HTTP는 기본이 연결을 유지하지 않는 모델
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
   예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있음

비연결성 한계와 극복
- TCP/IP 연결을 새로 맺어야 한다. 3 way handshake 시간 추가가 되어서 클라이언트의 시간을 잡아먹는다.
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 수많은 자원이 함께 다운로드한다.
- 하지만 지금은 HTTP 지속 연결(Persistend Connections)로 문제 해결
- HTTP/2, HTTP/3 최적화되었다.

HTTP 초기 - 연결, 종료 낭비
- 연결 종료 연결 종료 반복하면 메모리 낭비, 시간 잡아먹는다.

HTTP 지속 연결(Persistent Connections)
- 시간이 단축된다.

스테이스리스를 기억하자
(서버 개발자들이 어려워하는 업무)
- 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
   예) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록
   예) 저녁 6:00 선착순 1000명 치킨 할인 이벤트 -> 수만명 동시 요청
최대한 스테이스리스 하게 설계해야 한다.

HTTP 메서드
종류 : GET, POST, PUT, DELETE
- 서버가 수행해야 할 동작 과정
    - GET : 리소스조회
    - POST : 요청 내역 처리

API URI 고민
- 리소스의 의미는 뭘까?
    - 회원을 등록하고 수정하고 조회하는게 리소스가 아니다.
    - 회원이라는 개념 자체가 리소스다.
    - 예) 미네랄을 캐라 -> 미네랄이 리소스
- 리소스를 어떻게 식별하는게 좋을까?
    - 회원을 등록하고 수정하고 조회하는 것을 모두 배제
    - 회원이라는 리소스만 식별하면 된다. -> 회원 리소스를 URI에 매핑

리소스와 행위를 분리 - 가장 중요한 것은 리소스를 식별하는 것
- URI는 리소스만 식별
- 리소스와 해당 리소스를 대상으로 하는 행위를 분리
    - 리소스 : 회원
    - 행위 : 조회, 등록, 삭제, 변경
- 리소스는 명사, 행위는 동사(미네랄을 캐라)
- 행위는 어떻게 구분?

HTTP 메서드 종류 - 주요 메서드
- GET : 리소스 조회
- POST : 요청 데이터 처리, 주로 등록에 사용
- PUT : 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제

HTTP 메서드 종류 - 기타 메서드
- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

GET
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음.
- 조회 데이터는 최대한 GET을 사용하라.

POST
- 요청 데이터 처리
- 메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터를 처리
    - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
- 데이터가 변경되거나, 프로세스가 진행되거나, 어쩔수 없을 때 POST를 사용하면 된다.

POST 정리
1. 새 리소스 생성(등록)
    - 서버가 아직 식별하지 않은 새 리소스 생성
2. 요청 데이터 처리
    - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
    - 예) 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
    - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
3. 다른 메서드로 처리하기 애매한 경우
    - 예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
    - 애매하면 POST